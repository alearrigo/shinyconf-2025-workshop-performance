{
  "hash": "9d0733477682038f8eacb6e3f55b482d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Optimizing Performance in Shiny\"\nsubtitle: \"Tips and Best Practices\"\nauthor: \"Samuel Calderon\"\nformat: \n  revealjs:\n    theme: default\n    transition: slide\n    slide-number: true\n    logo: img/Appsilon_logo.svg\n    footer: \"ShinyConf 2025: 2025-04-09\"\nmermaid: \n  theme: default\nexecute: \n  eval: false\n  echo: true\n---\n\n\n\n## Material\n\n<https://github.com/Appsilon/shinyconf-2025-workshop-performance>\n\n## Workshop Structure (3 hours)\n\n- Introduction  \n- Optimization Cycle: Exercise 1 - Benchmarking  \n- Profiling: Exercise 2  \n- Optimization - Data: Exercise 3  \n- Optimization - Shiny: Exercise 4  \n- Optimization - Async: Exercise 5  \n- Advanced Topics  \n- Q&A\n\n# Introduction\n\n## Appsilon\n\n![](img/appsilon-web.png)\n\n<https://www.appsilon.com/>\n\n## We are hiring!\n\n- [R shiny developer](https://appsilon-1739358905.teamtailor.com/jobs/5638402-senior-r-shiny-developer?promotion=1368563-trackable-share-link-careers)\n- [R developer with life science bg](https://appsilon-1739358905.teamtailor.com/jobs/5669113-r-developer-with-life-science-background?promotion=1383980-trackable-share-link-careers)\n\nTo see more open positions: <https://www.appsilon.com/careers>\n\n## whoami\n\n- Political Scientist, now also R shiny developer\n- From Lima, Per√∫\n- Contact:\n  - Web: <https://www.samuelenrique.com>\n  - Github: <https://github.com/calderonsamuel>\n  - Linkedin: <https://www.linkedin.com/in/samuelcalderon/>\n  \n## Who are you?\n\n- Share in the chat:\n  - Name\n  - Where are you from? What time is it there?\n  - Background (briefly!)\n  - Your favorite niche R package\n\n\n# Optimization Cycle  \n\n## First Things First  \n\nWhat is a computer? The interaction of three main components\n\n![](img/computer-core-elements-eng.png)\n\n## What is Optimization?  \n\n![](img/computer-task-manager.png)\n\nIt depends on the need!  \n\nIn general, think in terms of time (CPU) or space (memory/storage). Money is a hidden factor.\n\n## The Cycle Illustrated  \n\n![](img/optimizacion-loop.png)\n\n<https://www.appsilon.com/post/optimize-shiny-app-performance>  \n\n## Key Aspects at Each Stage  \n\n- **Benchmarking**: Does it perform as expected?  \n- **Profiling**: Where are the bottlenecks?  \n- **Estimation/Recommendation**: What can be done?  \n- **Optimization**: Make decisions and implement  \n\n## Types of Benchmarking  \n\n- **Manual**  \n- **Advanced** ([shinyloadtest](https://rstudio.github.io/shinyloadtest/index.html))  \n\n## Exercise 1 - Benchmarking  \n\n![](img/benchmark-exercise.png)  \n\n---  \n\n- Test the app and note how long it takes to display the information for:  \n  - 3 different cities  \n  - 3 different maximum ages  \n\nLink: <https://01933b4a-2e76-51f9-79f4-629808c48a59.share.connect.posit.cloud/>\n\n# Profiling\n\n## Profiling - Tools in R  \n\nProfiling is a technique used to identify performance bottlenecks in your code.  \n\n## `{profvis}`  \n\nAn interactive tool that provides a detailed visualization of your code's execution time.  \n\n- Installation:  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"profvis\")\n```\n:::\n\n\n\n- Basic usage:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(profvis)\nprofvis({\n# Code to be profiled\n})\n```\n:::\n\n\n\n## shiny.tictoc  \n\nA tool that uses JavaScript to measure the time taken by actions in the app from the browser's perspective.  \n\nIt is very easy to add to a Shiny app:  \n\n```r\ntags$script(\n    src = \"https://cdn.jsdelivr.net/gh/Appsilon/shiny.tictoc@v0.2.0/shiny-tic-toc.min.js\"\n)\n```  \n\n- If you're unfamiliar with adding JavaScript: [Packaging JavaScript code for Shiny](https://shiny.posit.co/r/articles/build/packaging-javascript/)  \n\n---  \n\nRun any of these operations in the JavaScript console.  \n\n```js\n// Print out all measurements\nshowAllMeasurements()\n\n// To download all measurements as a CSV file\nexportMeasurements()\n\n// To print out summarised measurements (slowest rendering output, slowest server computation)\nshowSummarisedMeasurements()\n\n// To export an html file that visualizes measurements on a timeline\nawait exportHtmlReport()\n```\n\nMany browsers have developer tools where you can find a profiler while your app is running.  \n\n## Using profvis  \n\nLocate the tool in RStudio.\n\n![](img/profiling-01.png)\n\n---\n\nThe R console will display the \"Stop profiling\" button. This means the profiler is active.\n\n![](img/profiling-02.png)\n\nRun your Shiny app and interact with it. Then, you can stop the app and the profiler.  \n\n---  \n\nThe RStudio source panel will display a new view.\n\n![](img/profiling-03.png)\n\nThe upper section profiles each line of code, while the lower section displays a *FlameGraph*, indicating the time required for each operation.\n\n---\n\nYou can also access the \"Data\" tab.\n\n![](img/profiling-04.png)\n\nThis section shows how much time and memory each operation requires, providing a summary of the measurement.  \n\n---  \n\nFor a more in-depth review of `{profvis}`, you can refer to the official documentation:  \n\n- Examples: <https://profvis.r-lib.org/articles/rstudio.html>  \n- Integration with RStudio: <https://profvis.r-lib.org/articles/rstudio.html>  \n\n## Exercise 2 - Profiling  \n\nPerform profiling on the **\"app.R\"** file.  \n\n- Interpret the results:  \n  - What are the most critical points?  \n\nKeep in mind that you are testing this for a single user.\n\n## Optimization - Data  \n\n1. Use faster options for loading data  \n2. Use more efficient file formats  \n3. Pre-process calculations  \n4. Use databases (may require learning SQL)  \n\nYou can combine all these strategies!  \n\n## Loading Data Faster  \n\n- `data.table::fread()`  \n- `vroom::vroom()`  \n- `readr::read_csv()`  \n\n## Example  \n\n**DO NOT** run during the workshop as it takes time to execute.\n\n```r\nsuppressMessages(\n  microbenchmark::microbenchmark(\n    read.csv = read.csv(\"data/personal.csv\"),\n    read_csv = readr::read_csv(\"data/personal.csv\"),\n    vroom = vroom::vroom(\"data/personal.csv\"),\n    fread = data.table::fread(\"data/personal.csv\")\n  )\n)\n#> Unit: milliseconds\n#>      expr       min        lq      mean    median        uq       max neval\n#>  read.csv 1891.3824 2007.2517 2113.5217 2082.6016 2232.7825 2442.6901   100\n#>  read_csv  721.9287  820.4181  873.4603  866.7321  897.3488 1165.5929   100\n#>     vroom  176.7522  189.8111  205.2099  197.9027  206.2619  495.2784   100\n#>     fread  291.9581  370.8261  410.3995  398.9489  439.7827  638.0363   100\n```\n\n\n## Efficient Data Formats:  \n\n- **Parquet** (via `{arrow}`)  \n- **Feather** (compatible with Python)  \n- **fst**  \n- **RDS** (native to R)  \n\n## Example  \n\n**DO NOT** run during the workshop as it takes time to execute.\n\n```r\nsuppressMessages(\n  microbenchmark::microbenchmark(\n    read.csv = read.csv(\"data/personal.csv\"),\n    fst = fst::read_fst(\"data/personal.fst\"),\n    parquet = arrow::read_parquet(\"data/personal.parquet\"),\n    rds = readRDS(\"data/personal.rds\")\n  )\n)\n#> Unit: milliseconds\n#>      expr       min         lq       mean     median         uq      max neval\n#>  read.csv 1911.2919 2075.26525 2514.29114 2308.57325 2658.03690 4130.748   100\n#>       fst  201.1500  267.85160  339.73881  308.24680  357.19565  834.646   100\n#>   parquet   64.5013   67.29655   84.48485   70.70505   87.81995  405.147   100\n#>       rds  558.5518  644.32460  782.37898  695.07300  860.85075 1379.519   100\n```\n\n## Pre-processing Calculations  \n\n- **Pre-filtering**: Reduces size  \n- **Pre-transforming or aggregating**: Saves time  \n- **Using indexes**: Enables fast searches  \n\nThis is essentially **caching**, which is personally my favorite strategy.  \n\nIt can be challenging to use if real-time calculations are required (e.g., stock exchange, streaming data) or if data storage is restricted due to security or privacy concerns.\n\n\n## Without pre-processing\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# app.R\nsurvey <- read.csv(\"data/survey.csv\")\n\nserver <- function(input, output) {\n  output$table <- renderTable({\n      survey |> \n        filter(region == input$region) |> \n        summarise(avg_time = mean(temps_trajet_en_heures))\n    })\n}\n```\n:::\n\n\n\n## With pre-processing\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# script.R\nsurvey <- read.csv(\"data/survey.csv\")\nregions <- unique(survey$region)\n\nvalues <- regions |> \n  lapply(function(x) {\n    survey |> \n        dplyr::filter(region == x) |> \n        dplyr::summarise(avg_time = mean(temps_trajet_en_heures))\n  }) |> \n  setNames(regions)\n\nsaveRDS(values, \"data/values.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# app.R\nvalues <- readRDS(\"data/values.rds\")\n\nserver <- function(input, output) {\n  output$table <- renderTable(values[[input$region]])\n}\n```\n:::\n\n\n\n\n\n## Relational Databases\n\n- **Scalability**: Databases can efficiently handle large volumes of data.\n- **Fast Queries**: They allow complex queries to be performed quickly.\n- **Persistence**: Data is stored persistently, allowing for retrieval at any time.\n\n---\n\nSome notable examples are SQLite, MySQL, PostgreSQL, DuckDB.\n\n[freeCodeCamp](https://www.freecodecamp.org/learn/relational-database/) offers a good course for beginners.\n  \n\n## Exercise 3 - Data\n\nImplement an optimization strategy\n\n# Optimization - Shiny\n\n## When an app starts\n\n![](img/diagrama1-eng.png)\n\n---\n\nOn the Shiny side, optimization basically consists of making the app (actually, the CPU) do as little work as possible.\n\n## Reducing reactivity\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|3,4,5,9,10,11\"}\nserver <- function(input, output, session) {\n  output$table <- renderTable({\n    survey |> \n      filter(region == input$region) |> \n      filter(age <= input$age)\n  })\n  \n  output$histogram <- renderPlot({\n    survey |> \n      filter(region == input$region) |> \n      filter(age <= input$age) |> \n      ggplot(aes(temps_trajet_en_heures)) +\n      geom_histogram(bins = 20) +\n      theme_light()\n  })\n}\n```\n:::\n\n\n\n---\n\n`reactive()` to the rescue\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2-6|9,13\"}\nserver <- function(input, output, session) {\n  filtered <- reactive({\n    survey |> \n      filter(region == input$region) |> \n      filter(age <= input$age)\n  })\n  \n  output$table <- renderTable({\n    filtered()\n  })\n  \n  output$histogram <- renderPlot({\n    filtered() |> \n      ggplot(aes(temps_trajet_en_heures)) +\n      geom_histogram(bins = 20) +\n      theme_light()\n  })\n}\n```\n:::\n\n\n\n::: aside\nWe use more space (memory) to reduce time (CPU)\n:::\n\n## Controlling reactivity\n\nYou can chain `bindEvent()` to a `reactive()` or `observe()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_reactive <- reactive({\n  # slow reactive computation\n}) |> \n  bindEvent(input$trigger)\n\nobserve({\n  # slow reactive side effect\n}) |> \n  bindEvent(input$trigger)\n```\n:::\n\n\n\n::: aside\nIn previous versions, this was only possible with `observeEvent()` or `eventReactive()`.\n:::\n\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|5|16\"}\nui <- page_sidebar(\n  sidebar = sidebar(\n    selectInput(inputId = \"region\", ...),\n    sliderInput(inputId = \"age\", ...),\n    actionButton(inputId = \"compute\", label = \"Compute\")\n  ),\n  ...\n)\n\nserver <- function(input, output, session) {\n  filtered <- reactive({\n    survey |> \n      filter(region == input$region) |> \n      filter(age <= input$age)\n  }) |> \n    bindEvent(input$compute, ignoreNULL = FALSE)\n}\n```\n:::\n\n\n\nNow `filtered()` will only update when there is interaction with `input$compute`. \n\n::: aside\n`ignoreNULL = FALSE` allows the `reactive()` to execute when the app starts.\n:::\n\n## Caching Strategies\n\n`bindCache()` allows us to store computations on the fly based on certain *keys*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|7\"}\nserver <- function(input, output, session) {\n  filtered <- reactive({\n    survey |> \n      filter(region == input$region) |> \n      filter(age <= input$age)\n  }) |> \n    bindCache(input$region, input$age) |> \n    bindEvent(input$compute, ignoreNULL = FALSE)\n}\n```\n:::\n\n\n\nWhen a combination appears again, the value will be read instead of recalculated. \n\n::: aside\n`bindEvent()` is not mandatory to use `bindCache()`.\n:::\n\n---\n\n2. Cache levels:\n  - Application level: `cache = \"app\"` (default)\n  - Session level: `cache = \"session\"`\n  - Custom: `cache object + options`\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbindCache(..., cache = \"app\")\n```\n:::\n\n\n\nBy default, a maximum of 200 Mb of cache will be used.\n  \n::: aside\nPotentially high memory/storage usage to reduce processing time.\n:::\n\n## Server-browser communication\n\n- Sending data from the server to the browser takes time. \n  - Large data -> longer sending time.\n  - Slow connection -> longer sending time\n- Similarly, if the data is large, the browser takes longer to read and display it to the user. \nThe user's PC might be a toaster!\n\n---\n\n- What to do?\n  - Reduce frequency of transmissions (`bindEvent()`)\n  - Reduce size of transmissions\n  - Send the same information but in smaller parts (server-side processing or streaming)\n  \n## Reducing transmission size\n\nIt's possible to delegate certain calculations to the browser. For example, rendering a graph with [`{plotly}`](https://plotly.com/ggplot2/) instead of `{ggplot2}`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotly::plotlyOutput() # instead of plotOutput\nplotly::renderPlotly() # instead of renderPlot\n```\n:::\n\n\n\nWith this, the \"recipe\" of the graph is sent instead of the graph itself. Upon receiving the recipe, the browser handles rendering it.\n\n---\n\nThese functions translate `ggplot2` syntax to `plotly.js` syntax quite efficiently. It supports many types of graphs.\n\n![](img/shiny-plotly.png)\n\nBut don't trust it blindly, in many cases, the code will need adjustments. Especially when using `ggplot2` extensions.\n\n---\n\nOther similar packages:\n\n- [ggiraph](https://davidgohel.github.io/ggiraph/)\n- [echarts4r](https://echarts4r.john-coene.com/)\n- [highcharter](https://jkunst.com/highcharter/)\n- [r2d3](https://rstudio.github.io/r2d3/)\n- [shiny.gosling](https://appsilon.github.io/shiny.gosling/index.html) (genomics, by Appsilon)\n\n## Server-side processing\n\nFor tables, server-side processing allows paginating the result and sending to the browser only the page that is being displayed at the moment.\n\nThe `{DT}` package is a solid option.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDT::DTOutput() # instead of tableOutput()\nDT::renderDT() # instead of renderTable()\n```\n:::\n\n\n\n::: aside\nIf you were already using `{DT}`, did you know it did this by default?\n:::\n\n---\n\nAnother option:\n\n- `{reactable}` together with `{reactable.extras}` (by Appsilon).\n\n## Exercise 4 - Shiny\n\nImplement one of the previously mentioned optimizations.\n\n# Optimization - Async\n\n## Synchronous programming\n\n::: {.columns}\n\n::: {.column}\n\n- Tasks are executed sequentially\n- It's easy to understand and implement\n\n:::\n\n::: {.column}\n\n![](https://m.media-amazon.com/images/I/519J5jAClAL._AC_SL1001_.jpg)\n\n:::\n\n:::\n\nExample: A kitchen with one burner. If I started frying chicken, I can't fry anything else until I finish frying the chicken.\n\n\n## Asynchronous programming\n\n::: {.columns}\n::: {.column}\n\n- Tasks can start and run independently\n- While one task is being processed, others can be started or completed.\n\n:::\n\n::: {.column}\n\n![](https://m.media-amazon.com/images/I/71CuqWukldL._AC_SL1500_.jpg)\n:::\n\n:::\n\nExample: A kitchen with multiple burners. If I started frying chicken on one burner, I can fry something else on a different burner.\n\n---\n\nBurner == Process on the PC\n\n::: {.callout-warning title=\"Caution\"}\nMore burners also make it easier to burn the food!\n:::\n\n\n## Possible complications\n\n- The code becomes harder to understand\n- Without proper control, results can overwrite each other\n- Circular logic. Process A waits for Process B, which waits for Process A\n- Increases difficulty in debugging because errors occur elsewhere\n- Higher energy consumption\n\n## Benefits\n\n- Long operations don't block other operations\n- Flexibility: my system adapts to unexpected delays\n- The application remains responsive, doesn't \"hang\"\n- Efficient use of resources. \"I paid for 8 processors and I'm going to use 8 processors.\"\n- Scalability to a whole different level\n\n## Use cases\n\n- I/O operations:\n  - Database queries\n  - API requests\n- Intensive calculations\n\n## What do I need?\n\n- CPU with multiple cores/threads.\n- Packages:\n  - {promises}\n  - {future}\n  - ExtendedTask (Shiny 1.8.1+)\n  \n::: {.callout-note title=\"Note\"}\nExtendedTask is a fairly new resource. It's also possible to use just `future()` or `future_promise()` inside a reactive to achieve a similar effect, albeit with different advantages.\n:::\n\n## Initial setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|4-7\"}\nlibrary(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(future)\nlibrary(promises)\n\nplan(multisession)\n\nsurvey <- arrow::read_parquet(\"data/survey.parquet\")\n```\n:::\n\n\n\nThis tells the process running the app that created *futures* will be resolved in parallel sessions.\n\n## Procedure\n\n1. Create an `ExtendedTask` object.\n2. Bind to a task button\n3. Invoke the task\n4. Retrieve the results\n\n<https://shiny.posit.co/r/articles/improve/nonblocking/>\n  \n## Starting point - UI\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|5\"}\nui <- page_sidebar(\n  sidebar = sidebar(\n    selectInput(inputId = \"region\", ...),\n    sliderInput(inputId = \"age\", ...),\n    actionButton(inputId = \"compute\", label = \"Compute\")\n  ),\n  ...\n)\n```\n:::\n\n\n\n## Modifications - UI\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"5\"}\nui <- page_sidebar(\n  sidebar = sidebar(\n    selectInput(inputId = \"region\", ...),\n    sliderInput(inputId = \"age\", ...),\n    input_task_button(id = \"compute\", label = \"Compute\")\n  ),\n  ...\n)\n```\n:::\n\n\n\nWe change the `actionButton()` to `bslib::input_task_button()`. This button will have special behavior.\n\n## Starting point - Server\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|3-5|8|7\"}\nserver <- function(input, output, session) {\n  filtered <- reactive({\n    survey |> \n        filter(region == input$region) |> \n        filter(age <= input$age)\n  }) |> \n    bindCache(input$region, input$age) |> \n    bindEvent(input$compute, ignoreNULL = FALSE)\n  \n  output$table <- DT::renderDT(filtered())\n  ...\n}\n```\n:::\n\n\n\n## Modifications - Server\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output, session) {\n  filter_task <- ExtendedTask$new(function(p_survey, p_region, p_age) {\n    future_promise({\n      p_survey |> \n        dplyr::filter(region == p_region) |> \n        dplyr::filter(age <= p_age)\n    })\n  }) |> \n    bind_task_button(\"compute\")\n  \n  observe(filter_task$invoke(survey, input$region, input$age)) |> \n    bindEvent(input$compute, ignoreNULL = FALSE)\n  \n  filtered <- reactive(filter_task$result())\n  \n  output$table <- DT::renderDT(filtered())\n  ...\n}\n```\n:::\n\n\n\n## Modifications - Server\n\nStep 1: An `ExtendedTask` was created, which wraps a function. \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|4-6|3,7\"}\nserver <- function(input, output, session) {\n  filter_task <- ExtendedTask$new(function(p_survey, p_region, p_age) {\n    future_promise({\n      p_survey |> \n        dplyr::filter(region == p_region) |> \n        dplyr::filter(age <= p_age)\n    })\n  }) |> \n    bind_task_button(\"compute\")\n  \n  ...\n}\n```\n:::\n\n\n\n\nInside the function, we have our calculation logic wrapped in a `future_promise()`. The function assumes a blank session.\n\n## Modifications - Server\n\nStep 2: Bind to a task button\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|5,8\"}\nserver <- function(input, output, session) {\n  filter_task <- ExtendedTask$new(function(...) {\n    ...\n  }) |> \n    bind_task_button(\"compute\")\n  \n  observe(...) |> \n    bindEvent(input$compute, ignoreNULL = FALSE)\n\n  ...\n}\n```\n:::\n\n\n\n\n::: {.callout-note title=\"Note\"}\n`bind_task_button()` requires the same id as `input_task_button()`. `bindEvent()` accepts any reactive.\n:::\n\n## Modifications - Server\n\nStep 3: Invoke the task with `ExtendedTask$invoke()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2,7\"}\nserver <- function(input, output, session) {\n  filter_task <- ExtendedTask$new(function(p_survey, p_region, p_age) {\n    ...\n  }) |> \n    bind_task_button(\"compute\")\n  \n  observe(filter_task$invoke(survey, input$region, input$age)) |> \n    bindEvent(input$compute, ignoreNULL = FALSE)\n  \n  filtered <- reactive(filter_task$result())\n  \n  output$table <- DT::renderDT(filtered())\n  ...\n}\n```\n:::\n\n\n\nIt's provided with the necessary data to work. Note that `invoke()` has no return value (it's a side-effect).\n\n## Modifications - Server\n\nStep 4: Retrieve results with `ExtendedTask$result()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|10|12\"}\nserver <- function(input, output, session) {\n  filter_task <- ExtendedTask$new(function(...) {\n    ...\n  }) |> \n    bind_task_button(\"compute\")\n  \n  observe(filter_task$invoke(...)) |> \n    bindEvent(input$compute, ignoreNULL = FALSE)\n  \n  filtered <- reactive(filter_task$result())\n  \n  output$table <- DT::renderDT(filtered())\n  ...\n}\n```\n:::\n\n\n\n`result()` behaves like any reactive. \n\n## Modifications - Server\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output, session) {\n  filter_task <- ExtendedTask$new(function(p_survey, p_region, p_age) {\n    future_promise({\n      p_survey |> \n        dplyr::filter(region == p_region) |> \n        dplyr::filter(age <= p_age)\n    })\n  }) |> \n    bind_task_button(\"compute\")\n  \n  observe(filter_task$invoke(survey, input$region, input$age)) |> \n    bindEvent(input$compute, ignoreNULL = FALSE)\n  \n  filtered <- reactive(filter_task$result())\n  \n  output$table <- DT::renderDT(filtered())\n  ...\n}\n```\n:::\n\n\n\nWe lost the cache! `ExtendedTask()` is not 100% compatible with the caching strategies seen.\n\n## Exercise 5 - Async\n\n- Implement async for one of the plots\n- Discussion: is it worth it?\n\n## All together\n\nHere the app was deployed with all the improvements seen in the exercises. Also, `survey` uses the complete data, instead of a sample by region.\n\nLink: <https://01933e23-3162-29f7-ec09-ce351b4b4615.share.connect.posit.cloud/->\n\n::: aside\nThe platform allowed 8 GB of RAM and 2 CPU cores.\n:::\n\n# Advanced topics\n\n## Representing complexity\n\n[Big O notation](https://www.freecodecamp.org/news/big-o-notation-why-it-matters-and-why-it-doesnt-1674cfa8a23c/)\n\n![](https://www.freecodecamp.org/news/content/images/2021/06/1_KfZYFUT2OKfjekJlCeYvuQ.jpeg)\n\n\n## Understanding complexity\n\n[Algorithms and data structures](https://blog.algomaster.io/p/how-i-mastered-data-structures-and-algorithms)\n\n![](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Feb93edef-9bb2-45f5-a0cd-fd44f23e44f0_1728x1046.png)\n\n## Facing complexity\n\n- Modularization\n  - [shiny](https://mastering-shiny.org/scaling-modules.html)\n  - [box](https://github.com/klmr/box)\n- [Testing](https://mastering-shiny.org/scaling-testing.html)\n- File structure\n\n[`{rhino}`](https://appsilon.github.io/rhino/) comes with all of this!\n\n\n# Questions\n\n# Thank you!\n\n- Web: <https://www.samuelenrique.com>\n- Github: <https://github.com/calderonsamuel>\n- Linkedin: <https://www.linkedin.com/in/samuelcalderon/>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}